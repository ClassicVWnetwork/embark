#!/usr/bin/env node

/* global __dirname __filename process require */

// this script shouldn't use JS syntax or APIs *un*supported by any node
// version >=4.0.0, so unsupported versions from v4.0.0+ will get embarklog
// error output instead of a syntax error or runtime error
// See: https://node.green/

// KEY ASSUMPTION: for a DApp to be valid, from embark's perspective, it must
// have a parsable embark.json file in its top-level directory; if that
// requirement changes in the future (hypothetical example: embark.json info
// can be embedded in package.json under `{"embark": {...}}` vs. stored in a
// separate file) then this script must be revised

function main() {
  var noShim = false;
  var idx = process.argv.indexOf('--no-shim');
  if (idx > -1) {
    process.argv.splice(idx, 1);
    noShim = true;
  }

  if (noShim) {
    // fast code path for cmd execution
    return EmbarkCmd.prototype.exec();
  }

  var invokedEmbark = (new EmbarkCmd(__filename)).handle();
  var localEmbark;

  // findUp search begins in process.cwd() by default, but embark.json could
  // be in a subdir if embark was invoked via `npm run` (which changes cwd to
  // package.json's dir) and the package.json is in a dir above the top-level
  // DApp dir; so start at INIT_CWD if that has been set (by npm, presumably)
  // See: https://docs.npmjs.com/cli/run-script
  var INIT_CWD = process.env.INIT_CWD ? process.env.INIT_CWD : process.cwd();
  // allow for env override
  INIT_CWD = process.env.DAPP_PATH ? process.env.DAPP_PATH : INIT_CWD;
  var embarkJson = (new EmbarkJson(
    findUp.sync('embark.json', {cwd: INIT_CWD})
      || path.join(INIT_CWD, 'embark.json'),
    process.argv[2]
  )).setup();

  var dappPath = embarkJson.dirname;
  // set working dir to dir of embark.json, assumed to be DApp's top-level dir
  process.chdir(dappPath);
  process.env.DAPP_PATH = dappPath;
  process.env.PWD = dappPath;

  /* attempt to find a "local" embark in or above but not below dappPath

     let `dappPath/(([../])*)bin/embark` be a local "containing" embark

     let `dappPath/(([../])*)node_modules/embark/bin/embark` be a local
     "installed" embark

     if a local installed embark is found but is higher in the dir structure
     than a found local containing embark, containing embark will be
     preferred

     according to the above rule and current implementation: if a local
     installed embark is found within a local containing embark's own
     node_modules (that would be weird), installed embark will be preferred

     invoked embark may find itself as local embark, but that is detected prior
     to cmd execution by comparing `cmdrealpath` props

     if no local embark is found then cmd execution will use invoked embark */

  var containingEmbark = (
    new EmbarkCmdLocalContaining(
      findUp.sync('bin/embark', {cwd: dappPath}),
      invokedEmbark
    )
  ).setup();

  var installedEmbark = (
    new EmbarkCmdLocalInstalled(
      findUp.sync('node_modules/embark/bin/embark', {cwd: dappPath}),
      invokedEmbark
    )
  ).setup();

  containingEmbark.setActive(installedEmbark);
  installedEmbark.setActive(containingEmbark);

  // only one of the two or neither will be active
  if (installedEmbark.active) {
    localEmbark = installedEmbark;
  }
  if (containingEmbark.active) {
    localEmbark = containingEmbark;
  }

  // look for package.json files from dappPath < ceilingDir
  var ceilingDir = localEmbark ? localEmbark.pkgDir : null;
  var closestPkgJson, foundPkgJson;
  var startDir = dappPath;

  function stop() {
    foundPkgJson = pkgUp.sync(startDir);
    if (foundPkgJson && !closestPkgJson) {
      closestPkgJson = foundPkgJson;
    }
    var dir = foundPkgJson ? path.dirname(foundPkgJson) : null;
    var stop = !dir
        || dir === ceilingDir
        || (ceilingDir && subdir(dir, ceilingDir));
    if (!stop) {
      startDir = path.join(startDir, '..');
    }
    return stop;
  }

  while (!stop()) {
    (new PkgJsonLocal(foundPkgJson)).handle();
  }

  localEmbark && localEmbark.log();
  embarkJson.log();

  if (!closestPkgJson && localEmbark instanceof EmbarkCmdLocalInstalled) {
    closestPkgJson = localEmbark.pkgJsonLocalExpected;
  }

  if (isDappCmd(embarkJson.cmd) && !closestPkgJson) {
    var loglevel = 'error';
    reportMissing(path.join(dappPath, 'package.json'), loglevel);
    reportMissingDappJson(embarkJson.cmd, loglevel, 'package', 'in or above');
    exitWithError();
  }

  process.env.PKG_PATH = closestPkgJson ? closestPkgJson.dirname: dappPath;

  var whichEmbark;
  if (localEmbark && localEmbark.cmdrealpath !== invokedEmbark.cmdrealpath) {
    whichEmbark = localEmbark;
  } else {
    whichEmbark = invokedEmbark;
  }

  process.env.EMBARK_PATH = whichEmbark.pkgDir;
  whichEmbark.exec();
}

// -----------------------------------------------------------------------------

var checkDeps = require('check-dependencies');
var embarklog = require('npmlog');
var findUp = require('find-up');
var fs = require('fs');
var path = require('path');
var parseJsonWithErrors = require('json-parse-better-errors');
var pkgUp = require('pkg-up');
var semver = require('semver');
var subdir = require('subdir');

embarklog.heading = 'embark';

var _logged = false;
function logged(which) {
  var embarklog_which = embarklog[which];
  return function () {
    _logged = true;
    embarklog_which.apply(embarklog, arguments);
  };
}

embarklog.error = logged('error');
embarklog.info = logged('info');
embarklog.warn = logged('warn');

function blankLineMaybe(which) {
  if (_logged) {
    console[which]();
  }
}

var isNpmRun = process.env.hasOwnProperty('npm_lifecycle_script');
function blankLineTrailingMaybe(which) {
  if (isNpmRun) {
    console[which]();
  }
}

function checkPkg(pkgDir, scopes) {
  try {
    var config = {packageDir: pkgDir};
    if (scopes) {
      config.scopeList = scopes;
    }
    var checked = checkDeps.sync(config);
    if (checked.error.length) {
      return checked.error;
    }
  } catch (e) {}
}

function exitWithError(code) {
  blankLineTrailingMaybe('error');
  process.exit(code == null ? 1 : code);
}

function isDappCmd(cmd) {
  return [
    void 0,
    '-V',
    '--version',
    '-h',
    '--help',
    'new',
    'demo',
    'version',
    'help'
  ].indexOf(cmd) === -1;
}

function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
}

function parseJson(filepath) {
  try {
    return require(filepath);
  } catch (e) {}
}

function parseRange(range) {
  try {
    return semver.Range(range).range;
  } catch (e) {}
}

function realpath(filepath) {
  try {
    return fs.realpathSync(filepath);
  } catch (e) {}
}

function reportMissing(filepath, loglevel) {
  try {
    // force the exception
    fs.realpathSync(filepath);
  } catch (e) {
    blankLineMaybe(loglevel);
    embarklog[loglevel]('path', e.path);
    embarklog[loglevel]('code', e.code);
    embarklog[loglevel]('errno', e.errno);
    embarklog[loglevel]('syscall', e.syscall);
    embarklog[loglevel](e.code.toLowerCase(), e.message);
  }
}

function reportMissingDappJson(cmd, loglevel, kind, where) {
  blankLineMaybe(loglevel);
  embarklog[loglevel](
    '',
    `Could not locate your DApp's ${kind}.json file`
  );
  embarklog[loglevel](
    '',
    `Make sure a valid ${kind}.json file exists ${where} your DApp's top-level directory`
  );
  if (isDappCmd(cmd)) {
    embarklog[loglevel](
      '',
      `Embark command '${cmd}' can only be used inside a valid DApp directory structure`
    );
  }
}

function reportPkgErrors(errors, filepath, loglevel) {
  blankLineMaybe(loglevel);
  embarklog[loglevel]('file', filepath);
  embarklog[loglevel]('code', `EPKGCHK`);
  embarklog[loglevel]('package', errors.join('\n'));
}

function reportUnparsable(filepath, loglevel) {
  try {
    // force the exception
    parseJsonWithErrors(stripBOM(fs.readFileSync(filepath)));
  } catch (e) {
    var basename = path.basename(filepath);
    blankLineMaybe(loglevel);
    embarklog[loglevel]('file', filepath);
    embarklog[loglevel]('code', `EJSONPARSE`);
    embarklog[loglevel]('JSON parse', `Failed to parse json`);
    embarklog[loglevel]('JSON parse', e.message);
    embarklog[loglevel]('JSON parse', `Failed to parse ${basename} data.`);
    embarklog[loglevel]('JSON parse', `${basename} must be actual JSON, not just JavaScript.`);
  }
}

// See: https://github.com/npm/cli/blob/v6.4.1/lib/utils/parse-json.js#L16
function stripBOM (content) {
  content = content.toString();
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

// -- json files ---------------------------------------------------------------

function Json(filepath) {
  this.filepath = filepath;
  this.dirname = void 0;
  this.json = void 0;
  this.realpath = void 0;
}

Json.prototype.handle = function () {
  this.setup();
  this.log();
  return this;
};

Json.prototype.log = function () {
  this.logMissingFile();
  this.logUnparsable();
};

Json.prototype.loglevel = 'warn';

Json.prototype.logMissingFile = function () {
  if (!this.realpath) {
    reportMissing(this.filepath, this.loglevel);
    return true;
  }
};

Json.prototype.logUnparsable = function () {
  if (this.realpath && !this.json) {
    reportUnparsable(this.filepath, this.loglevel);
    return true;
  }
};

Json.prototype.setDirname = function () {
  if (this.filepath) {
    this.dirname = path.dirname(this.filepath);
  }
};

Json.prototype.setJson = function () {
  if (this.realpath) {
    this.json = parseJson(this.filepath);
  }
};

Json.prototype.setRealpath = function () {
  if (this.filepath) {
    this.realpath = realpath(this.filepath);
  }
};

Json.prototype.setup = function () {
  this.setRealpath();
  this.setDirname();
  this.setJson();
  return this;
};

// -- embark.json --------------------------------------------------------------

function EmbarkJson(filepath, cmd) {
  Json.call(this, filepath);
  this.cmd = cmd;
}
EmbarkJson.prototype = Object.create(Json.prototype);
EmbarkJson.prototype.constructor = EmbarkJson;

EmbarkJson.prototype.loglevel = 'warn';

EmbarkJson.prototype.log = function () {
  this.logMissingFile();
  this.logUnparsable();
};

EmbarkJson.prototype.logMissingFile = function () {
  var oldlevel = this.loglevel;
  this.loglevel = 'error';
  if (isDappCmd(this.cmd) && Json.prototype.logMissingFile.call(this)) {
    reportMissingDappJson(this.cmd, this.loglevel, 'embark', 'in');
    exitWithError();
  }
  this.loglevel = oldlevel;
};

EmbarkJson.prototype.logUnparsable = function () {
  var _isDappCmd = isDappCmd(this.cmd);
  var oldlevel = this.loglevel;
  if (_isDappCmd) {
    this.loglevel = 'error';
  }
  if (Json.prototype.logUnparsable.call(this)) {
    console[this.loglevel]();
    embarklog[this.loglevel]('', `Could not parse your DApp's embark.json file`);
    if (_isDappCmd) {
      exitWithError();
    }
  }
  this.loglevel = oldlevel;
};

// -- package.json -------------------------------------------------------------

function PkgJson(filepath) {
  Json.call(this, filepath);
  this.noCheck = void 0;
}
PkgJson.prototype = Object.create(Json.prototype);
PkgJson.prototype.constructor = PkgJson;

PkgJson.prototype.checkPkg = function () {
  if (this.json && !this.noCheck) {
    this.pkgErrors = checkPkg(this.dirname, this.checkScopes);
  }
};

PkgJson.prototype.log = function () {
  Json.prototype.log.call(this);
  this.logPkgErrors();
};

PkgJson.prototype.logPkgErrors = function () {
  if (this.pkgErrors) {
    reportPkgErrors(this.pkgErrors, this.filepath, this.loglevel);
    return true;
  }
};

PkgJson.prototype.setup = function () {
  Json.prototype.setup.call(this);
  this.checkPkg();
  return this;
};

// -- package.json :: of an embark pkg -----------------------------------------

function PkgJsonEmbark(filepath, kind) {
  PkgJson.call(this, filepath);
  this.kind = kind || 'invoked';
  this.nodeRange = void 0;
  this.pkg = void 0;
  this.version = void 0;
}
PkgJsonEmbark.prototype = Object.create(PkgJson.prototype);
PkgJsonEmbark.prototype.constructor = PkgJsonEmbark;

PkgJsonEmbark.prototype.checkScopes = ['dependencies'];

PkgJsonEmbark.prototype.log = function () {
  PkgJson.prototype.log.call(this);
  this.logMissingVersion();
  this.logUnsupportedNode();
};

PkgJsonEmbark.prototype.logMissingFile = function () {
  var oldlevel = this.loglevel;
  this.loglevel = 'error';
  if (PkgJson.prototype.logMissingFile.call(this)) {
    console[this.loglevel]();
    embarklog[this.loglevel](
      '',
      `Could not locate ${this.kind} embark's package.json file`
    );
    exitWithError();
  }
  this.loglevel = oldlevel;
};

PkgJsonEmbark.prototype.logMissingVersion = function () {
  if (this.json && this.version === '???') {
    blankLineMaybe(this.loglevel);
    embarklog[this.loglevel]('file', this.filepath);
    embarklog[this.loglevel](
      '',
      `No version is specified in ${this.kind} embark's package.json file`
    );
    return true;
  }
};

PkgJsonEmbark.prototype.logPkgErrors = function () {
  var oldlevel = this.loglevel;
  this.loglevel = 'error';
  if (PkgJson.prototype.logPkgErrors.call(this)) {
    console[this.loglevel]();
    embarklog[this.loglevel](
      '',
      [`Dependencies are missing relative to ${this.kind} embark's package.json in:`,
       `${this.dirname}/`].join('\n')
    );
    exitWithError();
  }
  this.loglevel = oldlevel;
};

PkgJsonEmbark.prototype.logUnparsable = function () {
  var oldlevel = this.loglevel;
  this.loglevel = 'error';
  if (PkgJson.prototype.logUnparsable.call(this)) {
    console[this.loglevel]();
    embarklog[this.loglevel](
      `Could not parse ${this.kind} embark's package.json file`
    );
    exitWithError();
  }
  this.loglevel = oldlevel;
};

PkgJsonEmbark.prototype.logUnsupportedNode = function () {
  var ret;
  var nodeRange = this.nodeRange;
  if (typeof nodeRange === 'undefined') {
    blankLineMaybe(this.loglevel);
    embarklog[this.loglevel]('file', this.filepath);
    embarklog[this.loglevel](
      'engine',
      `package.json of ${this.kind} ${this.pkg} does not specify %j`,
      {engines: {node: '[semver]'}}
    );
    embarklog[this.loglevel](
      'engine',
      `Defaulting to: %j`, {engines: {node: this.nodeRangeDefault}}
    );
    ret = true;
    nodeRange = this.nodeRangeDefault;
  }

  nodeRange = parseRange(nodeRange);
  if (!nodeRange) {
    blankLineMaybe(this.loglevel);
    embarklog[this.loglevel]('file', this.filepath);
    embarklog[this.loglevel](
      'engine'
      `package.json of ${this.kind} ${this.pkg} does not specify a valid %j`,
      {engines: {node: '[semver]'}}
    );
    embarklog[this.loglevel](
      'engine',
      `Specified: %j`, {engines: {node: nodeRange}}
    );
    embarklog[this.loglevel](
      'engine',
      `Defaulting to: %j`, {engines: {node: this.defaultNodeRange}}
    );
    ret = true;
    nodeRange = this.nodeRangeDefault;
  }

  var procNodeVer = semver.clean(process.version);
  var oldlevel = this.loglevel;
  this.loglevel = 'error';
  if (!semver.satisfies(procNodeVer, nodeRange)) {
    blankLineMaybe(this.loglevel);
    embarklog[this.loglevel]('notsup', `Unsupported runtime`);
    embarklog[this.loglevel](
      'notsup',
      `${this.kind} ${this.pkg} is not compatible with your version of node`
    );
    embarklog[this.loglevel]('notsup', `Required:`, nodeRange);
    embarklog[this.loglevel]('notsup', `Actual:`, procNodeVer);
    exitWithError();
  }
  this.loglevel = oldlevel;
  return ret;
};

// if changing to the `nodeRangeDefault` value, make sure to manually check
// that it's a valid semver range, otherwise fallback logic in the prototype
// methods won't be reliable
PkgJsonEmbark.prototype.nodeRangeDefault = semver.Range('>=8.11.3').range;

PkgJsonEmbark.prototype.setNodeRange = function () {
  if (isObject(this.json)
      && this.json.hasOwnProperty('engines')
      && this.json.engines.hasOwnProperty('node')) {
    this.nodeRange = this.json.engines.node;
  }
};

PkgJsonEmbark.prototype.setPkg = function () {
  this.pkg = `embark@${this.version}`;
};

PkgJsonEmbark.prototype.setVersion = function () {
  if (isObject(this.json) && this.json.version) {
    this.version = this.json.version;
  } else {
    this.version = '???';
  }
};

PkgJsonEmbark.prototype.setup = function () {
  PkgJson.prototype.setup.call(this);
  this.setVersion();
  this.setPkg();
  this.setNodeRange();
  return this;
};

// -- package.json :: local to DApp --------------------------------------------

function PkgJsonLocal(filepath) {
  PkgJson.call(this, filepath);
}
PkgJsonLocal.prototype = Object.create(PkgJson.prototype);
PkgJsonLocal.prototype.constructor = PkgJsonLocal;

PkgJsonLocal.prototype.logMissingFile = function () {
  var oldlevel = this.loglevel;
  this.loglevel = 'error';
  if (PkgJson.prototype.logMissingFile.call(this)) {
    console[this.loglevel]();
    embarklog[this.loglevel](
      '',
      [`Could not resolve local package.json path with require('fs').realpathSync`
       `Maybe a broken symbolic link?`].join('\n')
    );
    exitWithError();
  }
  this.loglevel = oldlevel;
};

PkgJsonLocal.prototype.logPkgErrors = function () {
  var oldlevel = this.loglevel;
  this.loglevel = 'error';
  if (PkgJson.prototype.logPkgErrors.call(this)) {
    console[this.loglevel]();
    embarklog[this.loglevel](
      '',
      [`Dependencies are missing relative to local package.json in:`,
       `${this.dirname}/`].join('\n')
    );
    exitWithError();
  }
  this.loglevel = oldlevel;
};

PkgJsonLocal.prototype.logUnparsable = function () {
  var oldlevel = this.loglevel;
  this.loglevel = 'error';
  if (PkgJson.prototype.logUnparsable.call(this)) {
    embarklog[this.loglevel]('', `Could not parse a local package.json file`);
    exitWithError();
  }
  this.loglevel = oldlevel;
};

// -- package.json :: local to DApp, expected by local installed embark --------

function PkgJsonLocalExpected(filepath) {
  PkgJsonLocal.call(this, filepath);
  this.embarkDep = void 0;
}
PkgJsonLocalExpected.prototype = Object.create(PkgJsonLocal.prototype);
PkgJsonLocalExpected.prototype.constructor = PkgJsonLocalExpected;

PkgJsonLocalExpected.prototype.log = function () {
  PkgJsonLocal.prototype.log.call(this);
  this.logMissingEmbarkDep();
};

PkgJsonLocalExpected.prototype.logMissingEmbarkDep = function () {
  var oldlevel = this.loglevel;
  this.loglevel = 'error';
  if (this.json && !this.embarkDep) {
    blankLineMaybe(this.loglevel);
    embarklog[this.loglevel]('file', this.filepath);
    embarklog[this.loglevel](
      '',
      [`Could not find embark specified in "dependencies" or "devDependencies" of local package.json file`,
       `But embark was found in node_modules relative to that file:`,
       `${this.dirname}/node_modules/embark/`].join('\n')
    );
    exitWithError();
  }
  this.loglevel = oldlevel;
};

PkgJsonLocalExpected.prototype.logMissingFile = function () {
  var oldlevel = this.loglevel;
  this.loglevel = 'error';
  // PkgJson.prototype NOT PkgJsonLocal.prototype
  if (PkgJson.prototype.logMissingFile.call(this)) {
    console[this.loglevel]();
    embarklog[this.loglevel](
      '',
      [`Could not find expected local package.json relative to embark found in:`
       `${this.dirname}/node_modules/embark/`].join('\n')
    );
    exitWithError();
  }
  this.loglevel = oldlevel;
};

PkgJsonLocalExpected.prototype.setEmbarkDep = function () {
  if (isObject(this.json)) {
    if (this.json.dependencies) {
      this.embarkDep = this.json.dependencies.embark;
    } else if (this.json.devDependencies) {
      this.embarkDep = this.json.devDependencies.embark;
    }
  }
};

PkgJsonLocalExpected.prototype.setup = function () {
  PkgJsonLocal.prototype.setup.call(this);
  this.setEmbarkDep();
  return this;
};

  var Cmd = require('../cmd/cmd');
  var cli = new Cmd();
  cli.process(process.argv);

    }
}

// -----------------------------------------------------------------------------

main();
