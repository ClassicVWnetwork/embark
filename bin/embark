#!/usr/bin/env node

/* global __dirname __filename process require */

// this script shouldn't use JS syntax or APIs *un*supported by any node
// version >=4.0.0, so unsupported versions from v4.0.0+ will get embarklog
// error output instead of a syntax error or runtime error
// See: https://node.green/

// KEY ASSUMPTION: for a DApp to be valid, from embark's perspective, it must
// have a parsable embark.json file in its top-level directory; if that
// requirement changes in the future (hypothetical example: embark.json info
// can be embedded in package.json under `{"embark": {...}}` vs. stored in a
// separate file) then this script must be revised

function main() {
  var noShim = false;
  var idx = process.argv.indexOf('--no-shim');
  if (idx > -1) {
    process.argv.splice(idx, 1);
    noShim = true;
  }

  if (noShim) {
    // fast code path for cmd execution
    return EmbarkCmd.prototype.exec();
  }

  var invokedEmbark = (new EmbarkCmd(__filename)).handle();
  var localEmbark;

  // findUp search begins in process.cwd() by default, but embark.json could
  // be in a subdir if embark was invoked via `npm run` (which changes cwd to
  // package.json's dir) and the package.json is in a dir above the top-level
  // DApp dir; so start at INIT_CWD if that has been set (by npm, presumably)
  // See: https://docs.npmjs.com/cli/run-script
  var INIT_CWD = process.env.INIT_CWD ? process.env.INIT_CWD : process.cwd();
  // allow for env override
  INIT_CWD = process.env.DAPP_PATH ? process.env.DAPP_PATH : INIT_CWD;
  var embarkJson = (new EmbarkJson(
    findUp.sync('embark.json', {cwd: INIT_CWD})
      || path.join(INIT_CWD, 'embark.json'),
    process.argv[2]
  )).setup();

  var dappPath = embarkJson.dirname;
  // set working dir to dir of embark.json, assumed to be DApp's top-level dir
  process.chdir(dappPath);
  process.env.DAPP_PATH = dappPath;
  process.env.PWD = dappPath;

  /* attempt to find a "local" embark in or above but not below dappPath

     let `dappPath/(([../])*)bin/embark` be a local "containing" embark

     let `dappPath/(([../])*)node_modules/embark/bin/embark` be a local
     "installed" embark

     if a local installed embark is found but is higher in the dir structure
     than a found local containing embark, containing embark will be
     preferred

     according to the above rule and current implementation: if a local
     installed embark is found within a local containing embark's own
     node_modules (that would be weird), installed embark will be preferred

     invoked embark may find itself as local embark, but that is detected prior
     to cmd execution by comparing `cmdrealpath` props

     if no local embark is found then cmd execution will use invoked embark */

  var containingEmbark = (
    new EmbarkCmdLocalContaining(
      findUp.sync('bin/embark', {cwd: dappPath}),
      invokedEmbark
    )
  ).setup();

  var installedEmbark = (
    new EmbarkCmdLocalInstalled(
      findUp.sync('node_modules/embark/bin/embark', {cwd: dappPath}),
      invokedEmbark
    )
  ).setup();

  containingEmbark.setActive(installedEmbark);
  installedEmbark.setActive(containingEmbark);

  // only one of the two or neither will be active
  if (installedEmbark.active) {
    localEmbark = installedEmbark;
  }
  if (containingEmbark.active) {
    localEmbark = containingEmbark;
  }

  // look for package.json files from dappPath < ceilingDir
  var ceilingDir = localEmbark ? localEmbark.pkgDir : null;
  var closestPkgJson, foundPkgJson;
  var startDir = dappPath;

  function stop() {
    foundPkgJson = pkgUp.sync(startDir);
    if (foundPkgJson && !closestPkgJson) {
      closestPkgJson = foundPkgJson;
    }
    var dir = foundPkgJson ? path.dirname(foundPkgJson) : null;
    var stop = !dir
        || dir === ceilingDir
        || (ceilingDir && subdir(dir, ceilingDir));
    if (!stop) {
      startDir = path.join(startDir, '..');
    }
    return stop;
  }

  while (!stop()) {
    (new PkgJsonLocal(foundPkgJson)).handle();
  }

  localEmbark && localEmbark.log();
  embarkJson.log();

  if (!closestPkgJson && localEmbark instanceof EmbarkCmdLocalInstalled) {
    closestPkgJson = localEmbark.pkgJsonLocalExpected;
  }

  if (isDappCmd(embarkJson.cmd) && !closestPkgJson) {
    var loglevel = 'error';
    reportMissing(path.join(dappPath, 'package.json'), loglevel);
    reportMissingDappJson(embarkJson.cmd, loglevel, 'package', 'in or above');
    exitWithError();
  }

  process.env.PKG_PATH = closestPkgJson ? closestPkgJson.dirname: dappPath;

  var whichEmbark;
  if (localEmbark && localEmbark.cmdrealpath !== invokedEmbark.cmdrealpath) {
    whichEmbark = localEmbark;
  } else {
    whichEmbark = invokedEmbark;
  }

  process.env.EMBARK_PATH = whichEmbark.pkgDir;
  whichEmbark.exec();
}

// -----------------------------------------------------------------------------

var checkDeps = require('check-dependencies');
var embarklog = require('npmlog');
var findUp = require('find-up');
var fs = require('fs');
var path = require('path');
var parseJsonWithErrors = require('json-parse-better-errors');
var pkgUp = require('pkg-up');
var semver = require('semver');
var subdir = require('subdir');

embarklog.heading = 'embark';

var _logged = false;
function logged(which) {
  var embarklog_which = embarklog[which];
  return function () {
    _logged = true;
    embarklog_which.apply(embarklog, arguments);
  };
}

embarklog.error = logged('error');
embarklog.info = logged('info');
embarklog.warn = logged('warn');

function blankLineMaybe(which) {
  if (_logged) {
    console[which]();
  }
}

var isNpmRun = process.env.hasOwnProperty('npm_lifecycle_script');
function blankLineTrailingMaybe(which) {
  if (isNpmRun) {
    console[which]();
  }
}

function checkPkg(pkgDir, scopes) {
  try {
    var config = {packageDir: pkgDir};
    if (scopes) {
      config.scopeList = scopes;
    }
    var checked = checkDeps.sync(config);
    if (checked.error.length) {
      return checked.error;
    }
  } catch (e) {}
}

function exitWithError(code) {
  blankLineTrailingMaybe('error');
  process.exit(code == null ? 1 : code);
}

function isDappCmd(cmd) {
  return [
    void 0,
    '-V',
    '--version',
    '-h',
    '--help',
    'new',
    'demo',
    'version',
    'help'
  ].indexOf(cmd) === -1;
}

function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
}

function parseJson(filepath) {
  try {
    return require(filepath);
  } catch (e) {}
}

function parseRange(range) {
  try {
    return semver.Range(range).range;
  } catch (e) {}
}

function realpath(filepath) {
  try {
    return fs.realpathSync(filepath);
  } catch (e) {}
}

function reportMissing(filepath, loglevel) {
  try {
    // force the exception
    fs.realpathSync(filepath);
  } catch (e) {
    blankLineMaybe(loglevel);
    embarklog[loglevel]('path', e.path);
    embarklog[loglevel]('code', e.code);
    embarklog[loglevel]('errno', e.errno);
    embarklog[loglevel]('syscall', e.syscall);
    embarklog[loglevel](e.code.toLowerCase(), e.message);
  }
}

function reportMissingDappJson(cmd, loglevel, kind, where) {
  blankLineMaybe(loglevel);
  embarklog[loglevel](
    '',
    `Could not locate your DApp's ${kind}.json file`
  );
  embarklog[loglevel](
    '',
    `Make sure a valid ${kind}.json file exists ${where} your DApp's top-level directory`
  );
  if (isDappCmd(cmd)) {
    embarklog[loglevel](
      '',
      `Embark command '${cmd}' can only be used inside a valid DApp directory structure`
    );
  }
}

function reportPkgErrors(errors, filepath, loglevel) {
  blankLineMaybe(loglevel);
  embarklog[loglevel]('file', filepath);
  embarklog[loglevel]('code', `EPKGCHK`);
  embarklog[loglevel]('package', errors.join('\n'));
}

function reportUnparsable(filepath, loglevel) {
  try {
    // force the exception
    parseJsonWithErrors(stripBOM(fs.readFileSync(filepath)));
  } catch (e) {
    var basename = path.basename(filepath);
    blankLineMaybe(loglevel);
    embarklog[loglevel]('file', filepath);
    embarklog[loglevel]('code', `EJSONPARSE`);
    embarklog[loglevel]('JSON parse', `Failed to parse json`);
    embarklog[loglevel]('JSON parse', e.message);
    embarklog[loglevel]('JSON parse', `Failed to parse ${basename} data.`);
    embarklog[loglevel]('JSON parse', `${basename} must be actual JSON, not just JavaScript.`);
  }
}

// See: https://github.com/npm/cli/blob/v6.4.1/lib/utils/parse-json.js#L16
function stripBOM (content) {
  content = content.toString();
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

  }
}

  var Cmd = require('../cmd/cmd');
  var cli = new Cmd();
  cli.process(process.argv);

    }
}

// -----------------------------------------------------------------------------

main();
